"""
    The Enlighten Systems API

    The Enlighten Systems API is a JSON-based API that provides access to performance data for a PV system. By using the Enlighten Systems API, you agree to the Enphase Energy API License Agreement.  Please note that the Enlighten Systems API does not provide performance data at a panel or microinverter level.  # noqa: E501

    The version of the OpenAPI document: 2.0
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from enlighten.api_client import ApiClient, Endpoint as _Endpoint
from enlighten.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from enlighten.model.client_error import ClientError
from enlighten.model.conflict_error import ConflictError
from enlighten.model.connection_type import ConnectionType
from enlighten.model.consumption_lifetime_response import ConsumptionLifetimeResponse
from enlighten.model.consumption_stats_response import ConsumptionStatsResponse
from enlighten.model.energy_lifetime_response import EnergyLifetimeResponse
from enlighten.model.envoys_response import EnvoysResponse
from enlighten.model.inventory_response import InventoryResponse
from enlighten.model.inverters_summary_by_envoy_or_site_response import InvertersSummaryByEnvoyOrSiteResponse
from enlighten.model.monthly_production_response import MonthlyProductionResponse
from enlighten.model.not_found_error import NotFoundError
from enlighten.model.production_meter_readings_response import ProductionMeterReadingsResponse
from enlighten.model.rgm_stats_response import RgmStatsResponse
from enlighten.model.search_system_id_response import SearchSystemIdResponse
from enlighten.model.server_error import ServerError
from enlighten.model.stats_response import StatsResponse
from enlighten.model.status import Status
from enlighten.model.summary_response import SummaryResponse
from enlighten.model.systems_response import SystemsResponse
from enlighten.model.unprocessable_entity_error import UnprocessableEntityError


class DefaultApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.consumption_lifetime_endpoint = _Endpoint(
            settings={
                'response_type': (ConsumptionLifetimeResponse,),
                'auth': [
                    'ApiKey'
                ],
                'endpoint_path': '/systems/{system_id}/consumption_lifetime',
                'operation_id': 'consumption_lifetime',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_id',
                    'system_id',
                    'start_date',
                    'end_date',
                ],
                'required': [
                    'user_id',
                    'system_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_id':
                        (str,),
                    'system_id':
                        (int,),
                    'start_date':
                        (date,),
                    'end_date':
                        (date,),
                },
                'attribute_map': {
                    'user_id': 'user_id',
                    'system_id': 'system_id',
                    'start_date': 'start_date',
                    'end_date': 'end_date',
                },
                'location_map': {
                    'user_id': 'query',
                    'system_id': 'path',
                    'start_date': 'query',
                    'end_date': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.consumption_stats_endpoint = _Endpoint(
            settings={
                'response_type': (ConsumptionStatsResponse,),
                'auth': [
                    'ApiKey'
                ],
                'endpoint_path': '/systems/{system_id}/consumption_stats',
                'operation_id': 'consumption_stats',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_id',
                    'system_id',
                    'start_at',
                    'end_at',
                ],
                'required': [
                    'user_id',
                    'system_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_id':
                        (str,),
                    'system_id':
                        (int,),
                    'start_at':
                        (int,),
                    'end_at':
                        (int,),
                },
                'attribute_map': {
                    'user_id': 'user_id',
                    'system_id': 'system_id',
                    'start_at': 'start_at',
                    'end_at': 'end_at',
                },
                'location_map': {
                    'user_id': 'query',
                    'system_id': 'path',
                    'start_at': 'query',
                    'end_at': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.energy_lifetime_endpoint = _Endpoint(
            settings={
                'response_type': (EnergyLifetimeResponse,),
                'auth': [
                    'ApiKey'
                ],
                'endpoint_path': '/systems/{system_id}/energy_lifetime',
                'operation_id': 'energy_lifetime',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_id',
                    'system_id',
                    'start_date',
                    'end_date',
                    'production',
                ],
                'required': [
                    'user_id',
                    'system_id',
                ],
                'nullable': [
                ],
                'enum': [
                    'production',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('production',): {

                        "ALL": "all"
                    },
                },
                'openapi_types': {
                    'user_id':
                        (str,),
                    'system_id':
                        (int,),
                    'start_date':
                        (date,),
                    'end_date':
                        (date,),
                    'production':
                        (str,),
                },
                'attribute_map': {
                    'user_id': 'user_id',
                    'system_id': 'system_id',
                    'start_date': 'start_date',
                    'end_date': 'end_date',
                    'production': 'production',
                },
                'location_map': {
                    'user_id': 'query',
                    'system_id': 'path',
                    'start_date': 'query',
                    'end_date': 'query',
                    'production': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.envoys_endpoint = _Endpoint(
            settings={
                'response_type': (EnvoysResponse,),
                'auth': [
                    'ApiKey'
                ],
                'endpoint_path': '/systems/{system_id}/envoys',
                'operation_id': 'envoys',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_id',
                    'system_id',
                ],
                'required': [
                    'user_id',
                    'system_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_id':
                        (str,),
                    'system_id':
                        (int,),
                },
                'attribute_map': {
                    'user_id': 'user_id',
                    'system_id': 'system_id',
                },
                'location_map': {
                    'user_id': 'query',
                    'system_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.inventory_endpoint = _Endpoint(
            settings={
                'response_type': (InventoryResponse,),
                'auth': [
                    'ApiKey'
                ],
                'endpoint_path': '/systems/{system_id}/inventory',
                'operation_id': 'inventory',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_id',
                    'system_id',
                ],
                'required': [
                    'user_id',
                    'system_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_id':
                        (str,),
                    'system_id':
                        (int,),
                },
                'attribute_map': {
                    'user_id': 'user_id',
                    'system_id': 'system_id',
                },
                'location_map': {
                    'user_id': 'query',
                    'system_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.inverters_summary_by_envoy_or_site_endpoint = _Endpoint(
            settings={
                'response_type': ([InvertersSummaryByEnvoyOrSiteResponse],),
                'auth': [
                    'ApiKey'
                ],
                'endpoint_path': '/systems/inverters_summary_by_envoy_or_site',
                'operation_id': 'inverters_summary_by_envoy_or_site',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_id',
                    'site_id',
                ],
                'required': [
                    'user_id',
                    'site_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_id':
                        (str,),
                    'site_id':
                        (int,),
                },
                'attribute_map': {
                    'user_id': 'user_id',
                    'site_id': 'site_id',
                },
                'location_map': {
                    'user_id': 'query',
                    'site_id': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.monthly_production_endpoint = _Endpoint(
            settings={
                'response_type': (MonthlyProductionResponse,),
                'auth': [
                    'ApiKey'
                ],
                'endpoint_path': '/systems/{system_id}/monthly_production',
                'operation_id': 'monthly_production',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_id',
                    'system_id',
                    'start_date',
                ],
                'required': [
                    'user_id',
                    'system_id',
                    'start_date',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_id':
                        (str,),
                    'system_id':
                        (int,),
                    'start_date':
                        (date,),
                },
                'attribute_map': {
                    'user_id': 'user_id',
                    'system_id': 'system_id',
                    'start_date': 'start_date',
                },
                'location_map': {
                    'user_id': 'query',
                    'system_id': 'path',
                    'start_date': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.production_meter_readings_endpoint = _Endpoint(
            settings={
                'response_type': (ProductionMeterReadingsResponse,),
                'auth': [
                    'ApiKey'
                ],
                'endpoint_path': '/systems/{system_id}/production_meter_readings',
                'operation_id': 'production_meter_readings',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_id',
                    'system_id',
                    'end_at',
                ],
                'required': [
                    'user_id',
                    'system_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_id':
                        (str,),
                    'system_id':
                        (int,),
                    'end_at':
                        (int,),
                },
                'attribute_map': {
                    'user_id': 'user_id',
                    'system_id': 'system_id',
                    'end_at': 'end_at',
                },
                'location_map': {
                    'user_id': 'query',
                    'system_id': 'path',
                    'end_at': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.rgm_stats_endpoint = _Endpoint(
            settings={
                'response_type': (RgmStatsResponse,),
                'auth': [
                    'ApiKey'
                ],
                'endpoint_path': '/systems/{system_id}/rgm_stats',
                'operation_id': 'rgm_stats',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_id',
                    'system_id',
                    'start_at',
                    'end_at',
                ],
                'required': [
                    'user_id',
                    'system_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_id':
                        (str,),
                    'system_id':
                        (int,),
                    'start_at':
                        (int,),
                    'end_at':
                        (int,),
                },
                'attribute_map': {
                    'user_id': 'user_id',
                    'system_id': 'system_id',
                    'start_at': 'start_at',
                    'end_at': 'end_at',
                },
                'location_map': {
                    'user_id': 'query',
                    'system_id': 'path',
                    'start_at': 'query',
                    'end_at': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.search_system_id_endpoint = _Endpoint(
            settings={
                'response_type': (SearchSystemIdResponse,),
                'auth': [
                    'ApiKey'
                ],
                'endpoint_path': '/systems/search_system_id',
                'operation_id': 'search_system_id',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_id',
                    'serial_num',
                ],
                'required': [
                    'user_id',
                    'serial_num',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_id':
                        (str,),
                    'serial_num':
                        (str,),
                },
                'attribute_map': {
                    'user_id': 'user_id',
                    'serial_num': 'serial_num',
                },
                'location_map': {
                    'user_id': 'query',
                    'serial_num': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.stats_endpoint = _Endpoint(
            settings={
                'response_type': (StatsResponse,),
                'auth': [
                    'ApiKey'
                ],
                'endpoint_path': '/systems/{system_id}/stats',
                'operation_id': 'stats',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_id',
                    'system_id',
                    'start_at',
                    'end_at',
                ],
                'required': [
                    'user_id',
                    'system_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_id':
                        (str,),
                    'system_id':
                        (int,),
                    'start_at':
                        (int,),
                    'end_at':
                        (int,),
                },
                'attribute_map': {
                    'user_id': 'user_id',
                    'system_id': 'system_id',
                    'start_at': 'start_at',
                    'end_at': 'end_at',
                },
                'location_map': {
                    'user_id': 'query',
                    'system_id': 'path',
                    'start_at': 'query',
                    'end_at': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.summary_endpoint = _Endpoint(
            settings={
                'response_type': (SummaryResponse,),
                'auth': [
                    'ApiKey'
                ],
                'endpoint_path': '/systems/{system_id}/summary',
                'operation_id': 'summary',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_id',
                    'system_id',
                    'summary_date',
                ],
                'required': [
                    'user_id',
                    'system_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_id':
                        (str,),
                    'system_id':
                        (int,),
                    'summary_date':
                        (date,),
                },
                'attribute_map': {
                    'user_id': 'user_id',
                    'system_id': 'system_id',
                    'summary_date': 'summary_date',
                },
                'location_map': {
                    'user_id': 'query',
                    'system_id': 'path',
                    'summary_date': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.systems_endpoint = _Endpoint(
            settings={
                'response_type': (SystemsResponse,),
                'auth': [
                    'ApiKey'
                ],
                'endpoint_path': '/systems',
                'operation_id': 'systems',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'user_id',
                    'next',
                    'limit',
                    'system_id',
                    'system_id2',
                    'system_name',
                    'system_name2',
                    'status',
                    'status2',
                    'reference',
                    'reference2',
                    'installer',
                    'installer2',
                    'connection_type',
                    'connection_type2',
                ],
                'required': [
                    'user_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'limit',
                ]
            },
            root_map={
                'validations': {
                    ('limit',): {

                        'inclusive_maximum': 1000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'user_id':
                        (str,),
                    'next':
                        (str,),
                    'limit':
                        (int,),
                    'system_id':
                        (int,),
                    'system_id2':
                        ([int],),
                    'system_name':
                        (str,),
                    'system_name2':
                        ([str],),
                    'status':
                        (Status,),
                    'status2':
                        ([Status],),
                    'reference':
                        (str,),
                    'reference2':
                        ([str],),
                    'installer':
                        (str,),
                    'installer2':
                        ([str],),
                    'connection_type':
                        (ConnectionType,),
                    'connection_type2':
                        ([ConnectionType],),
                },
                'attribute_map': {
                    'user_id': 'user_id',
                    'next': 'next',
                    'limit': 'limit',
                    'system_id': 'system_id',
                    'system_id2': 'system_id[]',
                    'system_name': 'system_name',
                    'system_name2': 'system_name[]',
                    'status': 'status',
                    'status2': 'status[]',
                    'reference': 'reference',
                    'reference2': 'reference[]',
                    'installer': 'installer',
                    'installer2': 'installer[]',
                    'connection_type': 'connection_type',
                    'connection_type2': 'connection_type[]',
                },
                'location_map': {
                    'user_id': 'query',
                    'next': 'query',
                    'limit': 'query',
                    'system_id': 'query',
                    'system_id2': 'query',
                    'system_name': 'query',
                    'system_name2': 'query',
                    'status': 'query',
                    'status2': 'query',
                    'reference': 'query',
                    'reference2': 'query',
                    'installer': 'query',
                    'installer2': 'query',
                    'connection_type': 'query',
                    'connection_type2': 'query',
                },
                'collection_format_map': {
                    'system_id2': 'multi',
                    'system_name2': 'multi',
                    'status2': 'multi',
                    'reference2': 'multi',
                    'installer2': 'multi',
                    'connection_type2': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )

    def consumption_lifetime(
        self,
        user_id,
        system_id,
        **kwargs
    ):
        """consumption_lifetime  # noqa: E501

        Returns a time series of energy consumption as measured by the consumption meter installed on the specified system. All measurements are in Watt-hours. If the system does not have a meter, returns `204` - No Content. If you don't have permission to view consumption data, the response code is `401`.  The time series includes one entry for each day from the `start_date` to the `end_date`. There are no gaps in the time series. If the response includes trailing zeroes, such as [909, 4970, 0, 0, 0], then no data has been reported for the last days in the series. You can check the system's status in the `meta` attribute of the response to determine when the system last reported and whether it has communication or metering problems.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.consumption_lifetime(user_id, system_id, async_req=True)
        >>> result = thread.get()

        Args:
            user_id (str):
            system_id (int):

        Keyword Args:
            start_date (date): The date on which to start the time series. Defaults to the system's operational date.. [optional]
            end_date (date): The last date to include in the time series. Defaults to yesterday or the last day the system reported, whichever is earlier.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ConsumptionLifetimeResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_id'] = \
            user_id
        kwargs['system_id'] = \
            system_id
        return self.consumption_lifetime_endpoint.call_with_http_info(**kwargs)

    def consumption_stats(
        self,
        user_id,
        system_id,
        **kwargs
    ):
        """consumption_stats  # noqa: E501

        Returns consumption as measured by the consumption meter installed on the specified system. If the total duration requested is more than one month, returns one month of intervals. Intervals are 15 minutes in length and start at the top of the hour.  Requests for times that do not fall on the 15-minute marks are rounded down. For example, a request for 08:01, 08:08, 08:11, or 08:14 is treated as a request for 08:00. Intervals are listed by their end dates; therefore, the first interval returned is 15 minutes after the requested start date.  If the system doesn't have any consumption meters installed, the response includes an empty intervals array.  If you don't have permission to view consumption data, the response code is `401`.  Under some conditions, data for a given period may be temporarily unavailable.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.consumption_stats(user_id, system_id, async_req=True)
        >>> result = thread.get()

        Args:
            user_id (str):
            system_id (int):

        Keyword Args:
            start_at (int): Start of period to report on in Unix epoch time. If no start is specified, the assumed start is midnight today, in the timezone of the system. If the start is earlier than one year ago, the response includes an empty intervals list. If the start is earlier than the system's `operational_date`, the response data begins with the first interval of the `operational_date`.. [optional]
            end_at (int): End of reporting period in Unix epoch time. If no end is specified, defaults to the time of the request. If the end is later than the last reported interval the response data ends with the last reported interval.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ConsumptionStatsResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_id'] = \
            user_id
        kwargs['system_id'] = \
            system_id
        return self.consumption_stats_endpoint.call_with_http_info(**kwargs)

    def energy_lifetime(
        self,
        user_id,
        system_id,
        **kwargs
    ):
        """energy_lifetime  # noqa: E501

        Returns a time series of energy produced on the system over its lifetime. All measurements are in Watt-hours.  The time series includes one entry for each day from the `start_date` to the `end_date`. There are no gaps in the time series. If the response includes trailing zeroes, such as `[909, 4970, 0, 0, 0]`, then no energy has been reported for the last days in the series. You can check the system's status in the `meta` attribute of the response to determine when the system last reported and whether it has communication or production problems.  If the system has a meter, the time series includes data as measured by the microinverters until the first full day after the meter has been installed, when it switches to using the data as measured by the meter. This is called the \"merged time series\". In addition, the response includes the attribute `meter_start_date`, to indicate where in the time series the meter measurements begin to be used. You can retrieve the complete time series from the meter and from the microinverters by adding the parameter `production=all` to the request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.energy_lifetime(user_id, system_id, async_req=True)
        >>> result = thread.get()

        Args:
            user_id (str):
            system_id (int):

        Keyword Args:
            start_date (date): The date on which to start the time series. Defaults to the system's operational date.. [optional]
            end_date (date): The last date to include in the time series. Defaults to yesterday or the last day the system reported, whichever is earlier.. [optional]
            production (str): When `all`, returns the merged time series plus the time series as reported by the microinverters and the meter on the system. Other values are ignored.. [optional] if omitted the server will use the default value of "all"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            EnergyLifetimeResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_id'] = \
            user_id
        kwargs['system_id'] = \
            system_id
        return self.energy_lifetime_endpoint.call_with_http_info(**kwargs)

    def envoys(
        self,
        user_id,
        system_id,
        **kwargs
    ):
        """envoys  # noqa: E501

        Returns a listing of all active Envoys currently deployed on the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.envoys(user_id, system_id, async_req=True)
        >>> result = thread.get()

        Args:
            user_id (str):
            system_id (int):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            EnvoysResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_id'] = \
            user_id
        kwargs['system_id'] = \
            system_id
        return self.envoys_endpoint.call_with_http_info(**kwargs)

    def inventory(
        self,
        user_id,
        system_id,
        **kwargs
    ):
        """inventory  # noqa: E501

        Returns a listing of active devices on the given system. A device is considered active if it has not been retired in Enlighten. \"Active\" does not imply that the device is currently reporting, producing, or measuring energy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.inventory(user_id, system_id, async_req=True)
        >>> result = thread.get()

        Args:
            user_id (str):
            system_id (int):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            InventoryResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_id'] = \
            user_id
        kwargs['system_id'] = \
            system_id
        return self.inventory_endpoint.call_with_http_info(**kwargs)

    def inverters_summary_by_envoy_or_site(
        self,
        user_id,
        site_id,
        **kwargs
    ):
        """inverters_summary_by_envoy_or_site  # noqa: E501

        Returns the summary along with the energy produced on the system over its lifetime.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.inverters_summary_by_envoy_or_site(user_id, site_id, async_req=True)
        >>> result = thread.get()

        Args:
            user_id (str):
            site_id (int): The identifier of the system.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            [InvertersSummaryByEnvoyOrSiteResponse]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_id'] = \
            user_id
        kwargs['site_id'] = \
            site_id
        return self.inverters_summary_by_envoy_or_site_endpoint.call_with_http_info(**kwargs)

    def monthly_production(
        self,
        user_id,
        system_id,
        start_date,
        **kwargs
    ):
        """monthly_production  # noqa: E501

        This endpoint is deprecated and will be removed in a future release. Use `production_meter_readings` or `energy_lifetime` instead.  Returns the energy production of the system for the month starting on the given date. The start date must be at least one month ago. If a meter or meters are installed on the system, measurements come from the meter; otherwise, measurements come from the microinverters.  This endpoint can return a response of Data Temporarily Unavailable.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.monthly_production(user_id, system_id, start_date, async_req=True)
        >>> result = thread.get()

        Args:
            user_id (str):
            system_id (int):
            start_date (date): Start date for reporting period. The reporting period ends on the previous day of the next month; for example, a `start_date` of 2011-07-20 returns data through 2011-06-19. When the start date is the first of a calendar month, the end end date is the last day of that month.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            MonthlyProductionResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_id'] = \
            user_id
        kwargs['system_id'] = \
            system_id
        kwargs['start_date'] = \
            start_date
        return self.monthly_production_endpoint.call_with_http_info(**kwargs)

    def production_meter_readings(
        self,
        user_id,
        system_id,
        **kwargs
    ):
        """production_meter_readings  # noqa: E501

        Returns the last known \"odometer\" reading of each revenue-grade production meter on the system as of the requested time.  This endpoint includes entries for every production meter on the requested system, regardless of whether the meter is currently in service or retired. `read_at` is the time at which the reading was taken, and is always less than or equal to the requested `end_at`. Commonly, the reading will be within 30 minutes of the requested `end_at`; however, larger deltas can occur and do not necessarily mean there is a problem with the meter or the system it is on. Systems that are configured to report infrequently can show large deltas on all meters, especially when `end_at` is close to the current time. Meters that have been retired from a system will show an `end_at` that doesn't change, and that eventually is far away from the current time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.production_meter_readings(user_id, system_id, async_req=True)
        >>> result = thread.get()

        Args:
            user_id (str):
            system_id (int):

        Keyword Args:
            end_at (int): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            ProductionMeterReadingsResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_id'] = \
            user_id
        kwargs['system_id'] = \
            system_id
        return self.production_meter_readings_endpoint.call_with_http_info(**kwargs)

    def rgm_stats(
        self,
        user_id,
        system_id,
        **kwargs
    ):
        """rgm_stats  # noqa: E501

        Returns performance statistics as measured by the revenue-grade meters installed on the specified system. If the total duration requested is more than one month, returns one month of intervals. Intervals are 15 minutes in length and start at the top of the hour.  Requests for times that do not fall on the 15-minute marks are rounded down. For example, a request for 08:01, 08:08, 08:11, or 08:14 is treated as a request for 08:00. Intervals are listed by their end dates; therefore, the first interval returned is 15 minutes after the requested start date.  If the system doesn't have any revenue-grade meters installed, the response includes an empty intervals array.  Under some conditions, data for a given period may be temporarily unavailable.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.rgm_stats(user_id, system_id, async_req=True)
        >>> result = thread.get()

        Args:
            user_id (str):
            system_id (int):

        Keyword Args:
            start_at (int): Start of period to report on in Unix epoch time. If no start is specified, the assumed start is midnight today, in the timezone of the system. If the start is earlier than one year ago, the response includes an empty intervals list. If the start is earlier than the system's `operational_date`, the response data begins with the first interval of the `operational_date`.. [optional]
            end_at (int): End of reporting period in Unix epoch time. If no end is specified, defaults to the time of the request. If the end is later than the last reported interval the response data ends with the last reported interval.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            RgmStatsResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_id'] = \
            user_id
        kwargs['system_id'] = \
            system_id
        return self.rgm_stats_endpoint.call_with_http_info(**kwargs)

    def search_system_id(
        self,
        user_id,
        serial_num,
        **kwargs
    ):
        """search_system_id  # noqa: E501

        Get system ID by envoy serial number.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_system_id(user_id, serial_num, async_req=True)
        >>> result = thread.get()

        Args:
            user_id (str):
            serial_num (str): Serial number of the envoy.

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            SearchSystemIdResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_id'] = \
            user_id
        kwargs['serial_num'] = \
            serial_num
        return self.search_system_id_endpoint.call_with_http_info(**kwargs)

    def stats(
        self,
        user_id,
        system_id,
        **kwargs
    ):
        """stats  # noqa: E501

        Returns performance statistics for the specified system as reported by microinverters installed on the system. If the total duration requested is more than one day, returns one day of intervals. Intervals are 5 minutes in length and start at the top of the hour.  Requests for times that do not fall on the 5-minute marks are rounded down. For example, a request for 08:01, 08:02, 08:03, or 08:04 is treated as a request for 08:00. Intervals are listed by their end dates; therefore, the first interval returned is 5 minutes after the requested start date.  The response includes intervals that have been reported for the requested period. Gaps in reporting are not filled with 0-value intervals. The dark hours on a system are an example of such a gap, because the microinverters do not produce at night.  Sometimes a request cannot be processed because the requested dates are invalid for the the system in question. Examples include asking for stats starting at a time that is later than the system's last reported interval, or asking for stats before a system has started production. In cases such as these, the response code is `422` and the response body includes an error reason as well as the parameters used to process the request.  If the system doesn't have any microinverters installed, the response includes an empty intervals array. Under some conditions, data for a given period may be temporarily unavailable.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stats(user_id, system_id, async_req=True)
        >>> result = thread.get()

        Args:
            user_id (str):
            system_id (int):

        Keyword Args:
            start_at (int): Start of reporting period in Unix epoch time. If no start is specified, defaults to midnight today, in the timezone of the system. If the start date is earlier than one year ago today, the response includes an empty intervals list. If the start is earlier than the system's `operational_date`, the response data begins with the `operational_date`.. [optional]
            end_at (int): End of reporting period in Unix epoch time. If no end is specified, the assumed end is now. If the end is later than the last reporting interval the response data ends with the last reported interval.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            StatsResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_id'] = \
            user_id
        kwargs['system_id'] = \
            system_id
        return self.stats_endpoint.call_with_http_info(**kwargs)

    def summary(
        self,
        user_id,
        system_id,
        **kwargs
    ):
        """summary  # noqa: E501

        Returns summary information for the specified system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.summary(user_id, system_id, async_req=True)
        >>> result = thread.get()

        Args:
            user_id (str):
            system_id (int):

        Keyword Args:
            summary_date (date): Start of reporting period. If no `summary_date` is provided, the start is the current day at midnight site-local time. Otherwise, the start is midnight site-local time of the requested day. If the requested date cannot be parsed or is in the future, the response includes an informative error message and `422` status.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            SummaryResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_id'] = \
            user_id
        kwargs['system_id'] = \
            system_id
        return self.summary_endpoint.call_with_http_info(**kwargs)

    def systems(
        self,
        user_id,
        **kwargs
    ):
        """systems  # noqa: E501

        Returns a list of systems for which the user can make API requests. There is a limit to the number of systems that can be returned at one time. If the first request does not return a full list, use the `next` attribute in the response body to request the next page of systems. By default, systems are returned in batches of 100. The maximum page size is 1000.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.systems(user_id, async_req=True)
        >>> result = thread.get()

        Args:
            user_id (str):

        Keyword Args:
            next (str): [optional]
            limit (int): [optional] if omitted the server will use the default value of 100
            system_id (int): [optional]
            system_id2 ([int]): [optional]
            system_name (str): [optional]
            system_name2 ([str]): [optional]
            status (Status): [optional]
            status2 ([Status]): [optional]
            reference (str): [optional]
            reference2 ([str]): [optional]
            installer (str): [optional]
            installer2 ([str]): [optional]
            connection_type (ConnectionType): [optional]
            connection_type2 ([ConnectionType]): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            SystemsResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['user_id'] = \
            user_id
        return self.systems_endpoint.call_with_http_info(**kwargs)

